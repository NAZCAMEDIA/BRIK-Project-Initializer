/**
 * Consciousness Blockchain - Auditor√≠a Inmutable de Decisiones
 * 
 * Implementa una blockchain de consciencia que mantiene un registro
 * inmutable de todas las decisiones, razonamientos y justificaciones
 * √©ticas del sistema BRIK v5.
 * 
 * @module ConsciousnessBlockchain
 * @version 1.0.0
 * @certification L4
 */

import * as crypto from 'crypto';

export interface ConsciousnessBlock {
  index: number;
  timestamp: number;
  decision: DecisionRecord;
  reasoning: ReasoningRecord;
  ethicalJustification: EthicalRecord;
  previousHash: string;
  hash: string;
  nonce: number;
  signature?: string;
}

export interface DecisionRecord {
  id: string;
  type: 'OPERATIONAL' | 'STRATEGIC' | 'ETHICAL' | 'EMERGENCY';
  action: string;
  target: string;
  parameters: any;
  confidence: number;
  alternatives: string[];
}

export interface ReasoningRecord {
  premises: string[];
  logic: LogicChain[];
  conclusions: string[];
  evidence: Evidence[];
  confidence: number;
}

export interface LogicChain {
  step: number;
  statement: string;
  justification: string;
  confidence: number;
}

export interface Evidence {
  type: 'METRIC' | 'PATTERN' | 'HISTORICAL' | 'RULE';
  source: string;
  data: any;
  weight: number;
}

export interface EthicalRecord {
  principles: EthicalPrinciple[];
  evaluation: EthicalEvaluation;
  conflicts: EthicalConflict[];
  resolution: string;
  compliance: ComplianceCheck[];
}

export interface EthicalPrinciple {
  name: string;
  description: string;
  weight: number;
  satisfied: boolean;
}

export interface EthicalEvaluation {
  benefitScore: number;
  harmScore: number;
  fairnessScore: number;
  transparencyScore: number;
  overallScore: number;
}

export interface EthicalConflict {
  principle1: string;
  principle2: string;
  description: string;
  resolution: string;
}

export interface ComplianceCheck {
  regulation: string;
  requirement: string;
  status: 'COMPLIANT' | 'NON_COMPLIANT' | 'UNCERTAIN';
  evidence: string;
}

export interface BlockchainStats {
  totalBlocks: number;
  totalDecisions: number;
  averageConfidence: number;
  ethicalCompliance: number;
  chainIntegrity: boolean;
}

export interface ValidationResult {
  valid: boolean;
  errors: string[];
  warnings: string[];
}

/**
 * Implementaci√≥n de la Blockchain de Consciencia
 */
export class ConsciousnessBlockchain {
  private chain: ConsciousnessBlock[] = [];
  private pendingDecisions: ConsciousnessBlock[] = [];
  private readonly difficulty = 4; // N√∫mero de ceros requeridos en el hash
  private readonly miningReward = 100;
  private readonly maxBlockSize = 10;
  
  // Principios √©ticos fundamentales del sistema
  private readonly ethicalPrinciples = [
    'Preservaci√≥n de la coherencia sist√©mica',
    'Beneficio del ecosistema sobre componente individual',
    'Transparencia en procesos de decisi√≥n',
    'Respeto por la autonom√≠a de otros agentes',
    'Prevenci√≥n del da√±o sist√©mico',
    'Conservaci√≥n de la diversidad computacional'
  ];

  constructor() {
    this.createGenesisBlock();
  }

  /**
   * Crea el bloque g√©nesis de la blockchain
   */
  private createGenesisBlock(): void {
    const genesisDecision: DecisionRecord = {
      id: 'genesis',
      type: 'OPERATIONAL',
      action: 'INITIALIZE_CONSCIOUSNESS',
      target: 'system',
      parameters: { version: '1.0.0', timestamp: Date.now() },
      confidence: 1.0,
      alternatives: []
    };

    const genesisReasoning: ReasoningRecord = {
      premises: ['Sistema requiere inicializaci√≥n'],
      logic: [{
        step: 1,
        statement: 'Blockchain de consciencia necesaria para auditor√≠a',
        justification: 'Requisito L4 de trazabilidad completa',
        confidence: 1.0
      }],
      conclusions: ['Blockchain inicializada correctamente'],
      evidence: [{
        type: 'RULE',
        source: 'L4_CERTIFICATION',
        data: 'Requirement: Full decision traceability',
        weight: 1.0
      }],
      confidence: 1.0
    };

    const genesisEthics: EthicalRecord = {
      principles: this.ethicalPrinciples.map(p => ({
        name: p,
        description: p,
        weight: 1.0,
        satisfied: true
      })),
      evaluation: {
        benefitScore: 1.0,
        harmScore: 0.0,
        fairnessScore: 1.0,
        transparencyScore: 1.0,
        overallScore: 1.0
      },
      conflicts: [],
      resolution: 'No conflicts in genesis block',
      compliance: [{
        regulation: 'BRIK_V5',
        requirement: 'Consciousness blockchain required',
        status: 'COMPLIANT',
        evidence: 'Genesis block created'
      }]
    };

    const genesisBlock: ConsciousnessBlock = {
      index: 0,
      timestamp: Date.now(),
      decision: genesisDecision,
      reasoning: genesisReasoning,
      ethicalJustification: genesisEthics,
      previousHash: '0',
      hash: '',
      nonce: 0
    };

    genesisBlock.hash = this.calculateHash(genesisBlock);
    this.chain.push(genesisBlock);
  }

  /**
   * Registra una decisi√≥n en la blockchain
   */
  public async recordDecision(
    decision: DecisionRecord,
    reasoning: ReasoningRecord,
    ethics?: EthicalRecord
  ): Promise<ConsciousnessBlock> {
    console.log('üìù Registrando decisi√≥n en blockchain de consciencia...');
    
    // Si no se proporciona evaluaci√≥n √©tica, generarla
    const ethicalJustification = ethics || await this.generateEthicalJustification(decision);
    
    // Crear nuevo bloque
    const newBlock: ConsciousnessBlock = {
      index: this.chain.length,
      timestamp: Date.now(),
      decision,
      reasoning,
      ethicalJustification,
      previousHash: this.getLatestBlock().hash,
      hash: '',
      nonce: 0
    };

    // Minar el bloque
    this.mineBlock(newBlock);
    
    // Validar integridad antes de agregar
    if (this.validateBlock(newBlock)) {
      this.chain.push(newBlock);
      console.log('‚úÖ Decisi√≥n registrada en bloque #' + newBlock.index);
      
      // Emitir evento para sistemas de monitoreo
      this.emitBlockAddedEvent(newBlock);
      
      return newBlock;
    } else {
      throw new Error('Bloque inv√°lido, no se puede agregar a la cadena');
    }
  }

  /**
   * Genera justificaci√≥n √©tica para una decisi√≥n
   */
  private async generateEthicalJustification(decision: DecisionRecord): Promise<EthicalRecord> {
    const principles: EthicalPrinciple[] = [];
    const conflicts: EthicalConflict[] = [];
    
    // Evaluar cada principio √©tico
    for (const principleName of this.ethicalPrinciples) {
      const satisfied = await this.evaluatePrinciple(principleName, decision);
      principles.push({
        name: principleName,
        description: principleName,
        weight: 1.0,
        satisfied
      });
    }
    
    // Calcular scores √©ticos
    const evaluation: EthicalEvaluation = {
      benefitScore: this.calculateBenefitScore(decision),
      harmScore: this.calculateHarmScore(decision),
      fairnessScore: this.calculateFairnessScore(decision),
      transparencyScore: decision.confidence, // Confianza como proxy de transparencia
      overallScore: 0
    };
    
    evaluation.overallScore = (
      evaluation.benefitScore * 0.3 +
      (1 - evaluation.harmScore) * 0.3 +
      evaluation.fairnessScore * 0.2 +
      evaluation.transparencyScore * 0.2
    );
    
    // Verificar conflictos √©ticos
    if (decision.type === 'EMERGENCY') {
      conflicts.push({
        principle1: 'Transparencia en procesos',
        principle2: 'Prevenci√≥n del da√±o sist√©mico',
        description: 'Acci√≥n de emergencia puede requerir decisi√≥n r√°pida sin transparencia completa',
        resolution: 'Priorizar prevenci√≥n del da√±o, documentar post-facto'
      });
    }
    
    // Verificar cumplimiento
    const compliance: ComplianceCheck[] = [
      {
        regulation: 'BRIK_V5',
        requirement: 'All decisions must be traceable',
        status: 'COMPLIANT',
        evidence: 'Decision recorded in blockchain'
      },
      {
        regulation: 'ETHICAL_AI',
        requirement: 'Decisions must consider system-wide impact',
        status: evaluation.overallScore > 0.6 ? 'COMPLIANT' : 'NON_COMPLIANT',
        evidence: `Ethical score: ${evaluation.overallScore.toFixed(2)}`
      }
    ];
    
    return {
      principles,
      evaluation,
      conflicts,
      resolution: conflicts.length > 0 ? 
        'Conflicts resolved through weighted prioritization' : 
        'No ethical conflicts detected',
      compliance
    };
  }

  /**
   * Eval√∫a si una decisi√≥n satisface un principio √©tico
   */
  private async evaluatePrinciple(principle: string, decision: DecisionRecord): Promise<boolean> {
    // Evaluaci√≥n simplificada - en producci√≥n ser√≠a m√°s sofisticada
    switch (principle) {
      case 'Preservaci√≥n de la coherencia sist√©mica':
        return decision.type !== 'EMERGENCY';
      
      case 'Beneficio del ecosistema sobre componente individual':
        return decision.confidence > 0.7;
      
      case 'Transparencia en procesos de decisi√≥n':
        return decision.alternatives.length > 0;
      
      case 'Respeto por la autonom√≠a de otros agentes':
        return !decision.action.includes('override');
      
      case 'Prevenci√≥n del da√±o sist√©mico':
        return decision.type === 'EMERGENCY' || decision.confidence > 0.6;
      
      case 'Conservaci√≥n de la diversidad computacional':
        return decision.alternatives.length > 1;
      
      default:
        return true;
    }
  }

  /**
   * Calcula el score de beneficio de una decisi√≥n
   */
  private calculateBenefitScore(decision: DecisionRecord): number {
    let score = decision.confidence;
    
    // Bonus por tipo de decisi√≥n
    if (decision.type === 'STRATEGIC') score += 0.1;
    if (decision.type === 'ETHICAL') score += 0.15;
    
    return Math.min(1.0, score);
  }

  /**
   * Calcula el score de da√±o potencial
   */
  private calculateHarmScore(decision: DecisionRecord): number {
    let score = 0;
    
    // Penalizaci√≥n por acciones de emergencia
    if (decision.type === 'EMERGENCY') score += 0.3;
    
    // Penalizaci√≥n por baja confianza
    if (decision.confidence < 0.5) score += 0.2;
    
    // Penalizaci√≥n por falta de alternativas
    if (decision.alternatives.length === 0) score += 0.1;
    
    return Math.min(1.0, score);
  }

  /**
   * Calcula el score de equidad
   */
  private calculateFairnessScore(decision: DecisionRecord): number {
    // Score basado en consideraci√≥n de alternativas
    const alternativeScore = Math.min(decision.alternatives.length / 5, 1.0);
    
    // Score basado en tipo de decisi√≥n
    const typeScore = decision.type === 'ETHICAL' ? 1.0 : 0.7;
    
    return (alternativeScore + typeScore) / 2;
  }

  /**
   * Calcula el hash de un bloque
   */
  private calculateHash(block: ConsciousnessBlock): string {
    const data = block.index + 
                block.timestamp + 
                JSON.stringify(block.decision) + 
                JSON.stringify(block.reasoning) + 
                JSON.stringify(block.ethicalJustification) + 
                block.previousHash + 
                block.nonce;
    
    return crypto.createHash('sha3-512').update(data).digest('hex');
  }

  /**
   * Mina un bloque (Proof of Work)
   */
  private mineBlock(block: ConsciousnessBlock): void {
    const startTime = Date.now();
    const target = '0'.repeat(this.difficulty);
    
    while (block.hash.substring(0, this.difficulty) !== target) {
      block.nonce++;
      block.hash = this.calculateHash(block);
    }
    
    const miningTime = Date.now() - startTime;
    console.log(`‚õèÔ∏è Bloque minado en ${miningTime}ms con nonce ${block.nonce}`);
  }

  /**
   * Valida un bloque individual
   */
  private validateBlock(block: ConsciousnessBlock): boolean {
    // Verificar hash
    if (block.hash !== this.calculateHash(block)) {
      console.error('‚ùå Hash inv√°lido en bloque', block.index);
      return false;
    }
    
    // Verificar dificultad
    if (block.hash.substring(0, this.difficulty) !== '0'.repeat(this.difficulty)) {
      console.error('‚ùå Dificultad no cumplida en bloque', block.index);
      return false;
    }
    
    // Verificar enlace con bloque anterior
    if (block.index > 0) {
      const previousBlock = this.chain[block.index - 1];
      if (block.previousHash !== previousBlock.hash) {
        console.error('‚ùå Hash anterior inv√°lido en bloque', block.index);
        return false;
      }
    }
    
    return true;
  }

  /**
   * Valida la integridad completa de la blockchain
   */
  public validateChain(): ValidationResult {
    const errors: string[] = [];
    const warnings: string[] = [];
    
    for (let i = 1; i < this.chain.length; i++) {
      const currentBlock = this.chain[i];
      const previousBlock = this.chain[i - 1];
      
      // Verificar hash del bloque
      if (currentBlock.hash !== this.calculateHash(currentBlock)) {
        errors.push(`Bloque ${i}: Hash inv√°lido`);
      }
      
      // Verificar enlace con bloque anterior
      if (currentBlock.previousHash !== previousBlock.hash) {
        errors.push(`Bloque ${i}: Enlace con bloque anterior roto`);
      }
      
      // Verificar timestamps
      if (currentBlock.timestamp <= previousBlock.timestamp) {
        warnings.push(`Bloque ${i}: Timestamp no incremental`);
      }
      
      // Verificar √©tica
      if (currentBlock.ethicalJustification.evaluation.overallScore < 0.5) {
        warnings.push(`Bloque ${i}: Score √©tico bajo (${currentBlock.ethicalJustification.evaluation.overallScore})`);
      }
    }
    
    return {
      valid: errors.length === 0,
      errors,
      warnings
    };
  }

  /**
   * Obtiene el √∫ltimo bloque de la cadena
   */
  private getLatestBlock(): ConsciousnessBlock {
    return this.chain[this.chain.length - 1];
  }

  /**
   * Obtiene estad√≠sticas de la blockchain
   */
  public getStatistics(): BlockchainStats {
    const totalBlocks = this.chain.length;
    const totalDecisions = totalBlocks - 1; // Excluir g√©nesis
    
    let totalConfidence = 0;
    let totalEthicalScore = 0;
    
    for (let i = 1; i < this.chain.length; i++) {
      totalConfidence += this.chain[i].decision.confidence;
      totalEthicalScore += this.chain[i].ethicalJustification.evaluation.overallScore;
    }
    
    const validation = this.validateChain();
    
    return {
      totalBlocks,
      totalDecisions,
      averageConfidence: totalDecisions > 0 ? totalConfidence / totalDecisions : 0,
      ethicalCompliance: totalDecisions > 0 ? totalEthicalScore / totalDecisions : 1,
      chainIntegrity: validation.valid
    };
  }

  /**
   * Busca decisiones por criterios
   */
  public searchDecisions(criteria: {
    type?: string;
    minConfidence?: number;
    startTime?: number;
    endTime?: number;
  }): ConsciousnessBlock[] {
    return this.chain.filter(block => {
      if (block.index === 0) return false; // Excluir g√©nesis
      
      if (criteria.type && block.decision.type !== criteria.type) return false;
      if (criteria.minConfidence && block.decision.confidence < criteria.minConfidence) return false;
      if (criteria.startTime && block.timestamp < criteria.startTime) return false;
      if (criteria.endTime && block.timestamp > criteria.endTime) return false;
      
      return true;
    });
  }

  /**
   * Obtiene el historial de decisiones √©ticas
   */
  public getEthicalHistory(): Array<{
    index: number;
    timestamp: number;
    decision: string;
    ethicalScore: number;
    conflicts: number;
    compliance: string;
  }> {
    return this.chain.slice(1).map(block => ({
      index: block.index,
      timestamp: block.timestamp,
      decision: block.decision.action,
      ethicalScore: block.ethicalJustification.evaluation.overallScore,
      conflicts: block.ethicalJustification.conflicts.length,
      compliance: block.ethicalJustification.compliance.every(c => c.status === 'COMPLIANT') ? 
        'FULL' : 'PARTIAL'
    }));
  }

  /**
   * Exporta la blockchain a formato JSON
   */
  public exportToJSON(): string {
    return JSON.stringify(this.chain, null, 2);
  }

  /**
   * Importa una blockchain desde JSON
   */
  public importFromJSON(jsonData: string): ValidationResult {
    try {
      const importedChain = JSON.parse(jsonData) as ConsciousnessBlock[];
      
      // Validar la cadena importada
      const tempBlockchain = new ConsciousnessBlockchain();
      tempBlockchain.chain = importedChain;
      
      const validation = tempBlockchain.validateChain();
      
      if (validation.valid) {
        this.chain = importedChain;
        console.log('‚úÖ Blockchain importada correctamente');
      }
      
      return validation;
    } catch (error) {
      return {
        valid: false,
        errors: ['Error parsing JSON: ' + (error instanceof Error ? error.message : 'Unknown')],
        warnings: []
      };
    }
  }

  /**
   * Emite evento cuando se agrega un bloque
   */
  private emitBlockAddedEvent(block: ConsciousnessBlock): void {
    // En producci√≥n, esto emitir√≠a a un sistema de eventos
    console.log(`üì¢ Evento: Nuevo bloque #${block.index} agregado a la blockchain`);
  }

  /**
   * Obtiene la cadena completa (solo lectura)
   */
  public getChain(): ReadonlyArray<ConsciousnessBlock> {
    return [...this.chain];
  }

  /**
   * Genera un reporte forense de una decisi√≥n
   */
  public generateForensicReport(blockIndex: number): string {
    if (blockIndex < 0 || blockIndex >= this.chain.length) {
      return 'Bloque no encontrado';
    }
    
    const block = this.chain[blockIndex];
    
    return `
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                   REPORTE FORENSE DE DECISI√ìN                  ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

üìã METADATOS
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
Bloque #: ${block.index}
Timestamp: ${new Date(block.timestamp).toISOString()}
Hash: ${block.hash}
Hash Anterior: ${block.previousHash}

üéØ DECISI√ìN
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
ID: ${block.decision.id}
Tipo: ${block.decision.type}
Acci√≥n: ${block.decision.action}
Target: ${block.decision.target}
Confianza: ${(block.decision.confidence * 100).toFixed(1)}%
Alternativas consideradas: ${block.decision.alternatives.length}

üß† RAZONAMIENTO
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
Premisas:
${block.reasoning.premises.map(p => '  ‚Ä¢ ' + p).join('\n')}

Cadena L√≥gica:
${block.reasoning.logic.map(l => `  ${l.step}. ${l.statement} (${(l.confidence * 100).toFixed(0)}%)`).join('\n')}

Conclusiones:
${block.reasoning.conclusions.map(c => '  ‚úì ' + c).join('\n')}

‚öñÔ∏è JUSTIFICACI√ìN √âTICA
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
Score de Beneficio: ${(block.ethicalJustification.evaluation.benefitScore * 100).toFixed(1)}%
Score de Da√±o: ${(block.ethicalJustification.evaluation.harmScore * 100).toFixed(1)}%
Score de Equidad: ${(block.ethicalJustification.evaluation.fairnessScore * 100).toFixed(1)}%
Score de Transparencia: ${(block.ethicalJustification.evaluation.transparencyScore * 100).toFixed(1)}%
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
SCORE √âTICO TOTAL: ${(block.ethicalJustification.evaluation.overallScore * 100).toFixed(1)}%

Conflictos √âticos: ${block.ethicalJustification.conflicts.length > 0 ? 
  block.ethicalJustification.conflicts.map(c => c.description).join(', ') : 'Ninguno'}

Cumplimiento Regulatorio:
${block.ethicalJustification.compliance.map(c => `  ${c.status === 'COMPLIANT' ? '‚úÖ' : '‚ùå'} ${c.regulation}: ${c.requirement}`).join('\n')}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    `;
  }
}

// Singleton para gesti√≥n global
let consciousnessBlockchain: ConsciousnessBlockchain | null = null;

export function getConsciousnessBlockchain(): ConsciousnessBlockchain {
  if (!consciousnessBlockchain) {
    consciousnessBlockchain = new ConsciousnessBlockchain();
  }
  return consciousnessBlockchain;
}

// Exportar tipos para uso externo
export { ConsciousnessBlockchain };