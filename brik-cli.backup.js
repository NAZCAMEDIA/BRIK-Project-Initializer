#!/usr/bin/env node

/**
 * üß¨ BRIK CLI - Sistema Interactivo de Gesti√≥n de Proyectos BRIK
 * Herramienta completa para crear y reestructurar proyectos con certificaci√≥n BRIK
 */

const readline = require('readline');
const path = require('path');
const fs = require('fs');
const { spawn, execSync } = require('child_process');

// Colores para la consola
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  dim: '\x1b[2m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
  white: '\x1b[37m'
};

// Utilidades de color
const color = (text, colorCode) => `${colorCode}${text}${colors.reset}`;
const log = {
  info: (msg) => console.log(color(`‚ÑπÔ∏è  ${msg}`, colors.cyan)),
  success: (msg) => console.log(color(`‚úÖ ${msg}`, colors.green)),
  warning: (msg) => console.log(color(`‚ö†Ô∏è  ${msg}`, colors.yellow)),
  error: (msg) => console.log(color(`‚ùå ${msg}`, colors.red)),
  title: (msg) => console.log(color(`\n${msg}`, colors.bright + colors.magenta)),
  subtitle: (msg) => console.log(color(msg, colors.bright + colors.blue))
};

// Interfaz de l√≠nea de comandos
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

// Funci√≥n para hacer preguntas
const question = (query) => new Promise((resolve) => {
  rl.question(color(query, colors.cyan), resolve);
});

// Funci√≥n para mostrar opciones y obtener selecci√≥n
const select = async (title, options) => {
  console.log(color(`\n${title}`, colors.bright + colors.yellow));
  options.forEach((opt, idx) => {
    console.log(color(`  ${idx + 1}. ${opt.label}`, colors.white));
  });
  
  const answer = await question('\nüëâ Selecciona una opci√≥n: ');
  const index = parseInt(answer) - 1;
  
  if (index >= 0 && index < options.length) {
    return options[index];
  } else {
    log.error('Opci√≥n inv√°lida. Por favor intenta de nuevo.');
    return await select(title, options);
  }
};

// Banner principal
const showBanner = () => {
  console.clear();
  console.log(color(`
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                                                                    ‚ïë
‚ïë     üß¨ BRIK PROJECT INITIALIZER v5.0 - Enterprise Edition üß¨      ‚ïë
‚ïë                                                                    ‚ïë
‚ïë          Sistema Completo de Gesti√≥n de Proyectos BRIK            ‚ïë
‚ïë         Certificaci√≥n | Reestructuraci√≥n | Validaci√≥n             ‚ïë
‚ïë                                                                    ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
`, colors.bright + colors.cyan));
  
  console.log(color(`
  Filosof√≠a: DAAF-BRIK-Circuitalidad Digital
  Principios: 100% Cobertura | Inmutabilidad | Living Code
  Certificaci√≥n: Nivel L3 Empresarial
`, colors.dim));
};

// Men√∫ principal
const mainMenu = async () => {
  const options = [
    {
      value: 'create-new',
      label: 'üöÄ Crear nuevo proyecto BRIK desde cero',
      handler: createNewProject
    },
    {
      value: 'create-smart',
      label: 'üß† Crear proyecto BRIK inteligente (con IA)',
      handler: createSmartProject
    },
    {
      value: 'restructure',
      label: 'üîÑ Reestructurar proyecto existente a BRIK',
      handler: restructureProject
    },
    {
      value: 'validate',
      label: 'üîç Validar certificaci√≥n BRIK de un proyecto',
      handler: validateProject
    },
    {
      value: 'analyze',
      label: 'üìä Analizar arquitectura de proyecto',
      handler: analyzeArchitecture
    },
    {
      value: 'docs',
      label: 'üìö Ver documentaci√≥n y gu√≠as BRIK',
      handler: showDocumentation
    },
    {
      value: 'config',
      label: '‚öôÔ∏è  Configuraci√≥n y preferencias',
      handler: showConfiguration
    },
    {
      value: 'exit',
      label: 'üö™ Salir',
      handler: () => process.exit(0)
    }
  ];
  
  const selected = await select('üìã MEN√ö PRINCIPAL', options);
  await selected.handler();
};

// Crear nuevo proyecto BRIK tradicional
const createNewProject = async () => {
  log.title('üöÄ CREAR NUEVO PROYECTO BRIK');
  
  const projectName = await question('\nüìù Nombre del proyecto: ');
  
  const languageOptions = [
    { value: 'rust', label: 'ü¶Ä Rust' },
    { value: 'typescript', label: 'üìò TypeScript' },
    { value: 'python', label: 'üêç Python' },
    { value: 'go', label: 'üêπ Go' }
  ];
  
  const language = await select('üíª Selecciona el lenguaje', languageOptions);
  
  const projectPath = await question(`\nüìÇ Ruta del proyecto (default: ./${projectName}): `) || `./${projectName}`;
  
  log.info('Creando proyecto BRIK tradicional...');
  
  try {
    // Ejecutar script de inicializaci√≥n
    const scriptPath = path.join(__dirname, 'init-brik-project.sh');
    const child = spawn('bash', [scriptPath, projectName, language.value], {
      stdio: 'inherit',
      cwd: path.dirname(projectPath)
    });
    
    child.on('close', async (code) => {
      if (code === 0) {
        log.success('¬°Proyecto BRIK creado exitosamente!');
        
        // Mostrar resumen
        showProjectSummary(projectPath, projectName, language.value);
        
        await question('\nPresiona Enter para volver al men√∫ principal...');
        await mainMenu();
      } else {
        log.error('Error al crear el proyecto');
        await question('\nPresiona Enter para volver al men√∫ principal...');
        await mainMenu();
      }
    });
  } catch (error) {
    log.error(`Error: ${error.message}`);
    await question('\nPresiona Enter para volver al men√∫ principal...');
    await mainMenu();
  }
};

// Crear proyecto BRIK inteligente con IA
const createSmartProject = async () => {
  log.title('üß† CREAR PROYECTO BRIK INTELIGENTE');
  
  // Verificar prerrequisitos
  if (!checkSmartPrerequisites()) {
    await question('\nPresiona Enter para volver al men√∫ principal...');
    await mainMenu();
    return;
  }
  
  const projectName = await question('\nüìù Nombre del proyecto: ');
  const description = await question('üìã Descripci√≥n del proyecto: ');
  
  const languageOptions = [
    { value: 'rust', label: 'ü¶Ä Rust' },
    { value: 'typescript', label: 'üìò TypeScript' },
    { value: 'python', label: 'üêç Python' }
  ];
  
  const language = await select('üíª Selecciona el lenguaje', languageOptions);
  
  const integrations = await question('\nüîå Integraciones (separadas por comas, ej: postgresql,redis,stripe): ');
  const projectPath = await question(`üìÇ Ruta del proyecto (default: ./${projectName}): `) || `./${projectName}`;
  
  log.info('Generando proyecto BRIK inteligente con IA...');
  console.log(color('  üß† Analizando dominio...', colors.dim));
  console.log(color('  üèóÔ∏è  Clasificando arquitectura...', colors.dim));
  console.log(color('  ‚ö° Generando c√≥digo funcional...', colors.dim));
  console.log(color('  üîç Validando principios BRIK...', colors.dim));
  
  try {
    const scriptPath = path.join(__dirname, 'init-brik-project.sh');
    const args = [
      projectName,
      '--smart',
      '--description', description,
      '--language', language.value,
      '--output', projectPath
    ];
    
    if (integrations) {
      args.push('--integrations', integrations);
    }
    
    const child = spawn('bash', [scriptPath, ...args], {
      stdio: 'inherit',
      cwd: __dirname
    });
    
    child.on('close', async (code) => {
      if (code === 0) {
        log.success('¬°Proyecto BRIK inteligente creado exitosamente!');
        
        // Mostrar an√°lisis generado
        showSmartProjectAnalysis(projectPath);
        
        await question('\nPresiona Enter para volver al men√∫ principal...');
        await mainMenu();
      } else {
        log.error('Error al crear el proyecto inteligente');
        await question('\nPresiona Enter para volver al men√∫ principal...');
        await mainMenu();
      }
    });
  } catch (error) {
    log.error(`Error: ${error.message}`);
    await question('\nPresiona Enter para volver al men√∫ principal...');
    await mainMenu();
  }
};

// Reestructurar proyecto existente
const restructureProject = async () => {
  log.title('üîÑ REESTRUCTURAR PROYECTO EXISTENTE A BRIK');
  
  const projectPath = await question('\nüìÇ Ruta del proyecto existente: ');
  
  if (!fs.existsSync(projectPath)) {
    log.error('El proyecto no existe en la ruta especificada');
    await question('\nPresiona Enter para volver al men√∫ principal...');
    await mainMenu();
    return;
  }
  
  // Detectar tipo de proyecto
  const projectType = detectProjectType(projectPath);
  log.info(`Tipo de proyecto detectado: ${projectType || 'desconocido'}`);
  
  const modeOptions = [
    { value: 'preserve', label: 'üîí Preservar c√≥digo existente (agregar estructura BRIK)' },
    { value: 'refactor', label: '‚ôªÔ∏è  Refactorizar c√≥digo a principios BRIK' },
    { value: 'analyze', label: 'üìä Solo analizar (sin cambios)' }
  ];
  
  const mode = await select('üîß Modo de reestructuraci√≥n', modeOptions);
  
  if (mode.value === 'analyze') {
    await analyzeProjectStructure(projectPath);
    await question('\nPresiona Enter para volver al men√∫ principal...');
    await mainMenu();
    return;
  }
  
  log.info('Iniciando reestructuraci√≥n BRIK...');
  
  try {
    // Crear backup
    const backupPath = `${projectPath}.backup-${Date.now()}`;
    log.info(`Creando backup en: ${backupPath}`);
    execSync(`cp -r "${projectPath}" "${backupPath}"`);
    
    // Aplicar reestructuraci√≥n
    await applyBrikRestructure(projectPath, mode.value, projectType);
    
    log.success('¬°Reestructuraci√≥n completada!');
    
    // Validar resultado
    log.info('Validando estructura BRIK...');
    await validateBrikStructure(projectPath);
    
    await question('\nPresiona Enter para volver al men√∫ principal...');
    await mainMenu();
  } catch (error) {
    log.error(`Error en reestructuraci√≥n: ${error.message}`);
    await question('\nPresiona Enter para volver al men√∫ principal...');
    await mainMenu();
  }
};

// Validar proyecto BRIK
const validateProject = async () => {
  log.title('üîç VALIDAR CERTIFICACI√ìN BRIK');
  
  const projectPath = await question('\nüìÇ Ruta del proyecto a validar: ');
  
  if (!fs.existsSync(projectPath)) {
    log.error('El proyecto no existe en la ruta especificada');
    await question('\nPresiona Enter para volver al men√∫ principal...');
    await mainMenu();
    return;
  }
  
  log.info('Ejecutando validaci√≥n BRIK completa...');
  
  try {
    // Ejecutar validador L3
    const validatorPath = path.join(__dirname, 'l3_certification_suite.js');
    
    if (fs.existsSync(validatorPath)) {
      const result = execSync(`node "${validatorPath}" "${projectPath}"`, { 
        encoding: 'utf8',
        stdio: 'pipe'
      });
      
      console.log(result);
      
      // Mostrar reporte
      const reportPath = path.join(projectPath, 'brik-l3-certification-report.json');
      if (fs.existsSync(reportPath)) {
        const report = JSON.parse(fs.readFileSync(reportPath, 'utf8'));
        showValidationReport(report);
      }
    } else {
      log.warning('Validador L3 no encontrado, usando validaci√≥n b√°sica...');
      await validateBrikStructure(projectPath);
    }
    
    await question('\nPresiona Enter para volver al men√∫ principal...');
    await mainMenu();
  } catch (error) {
    log.error(`Error en validaci√≥n: ${error.message}`);
    await question('\nPresiona Enter para volver al men√∫ principal...');
    await mainMenu();
  }
};

// Analizar arquitectura
const analyzeArchitecture = async () => {
  log.title('üìä ANALIZAR ARQUITECTURA DE PROYECTO');
  
  const projectPath = await question('\nüìÇ Ruta del proyecto: ');
  
  if (!fs.existsSync(projectPath)) {
    log.error('El proyecto no existe en la ruta especificada');
    await question('\nPresiona Enter para volver al men√∫ principal...');
    await mainMenu();
    return;
  }
  
  await analyzeProjectStructure(projectPath);
  
  await question('\nPresiona Enter para volver al men√∫ principal...');
  await mainMenu();
};

// Mostrar documentaci√≥n
const showDocumentation = async () => {
  log.title('üìö DOCUMENTACI√ìN BRIK');
  
  const docOptions = [
    { value: 'principles', label: 'üß¨ Principios BRIK y filosof√≠a DAAF' },
    { value: 'structure', label: 'üìÅ Estructura de directorios BRIK' },
    { value: 'coverage', label: 'üß™ Gu√≠a de 100% cobertura' },
    { value: 'smart', label: 'üß† Modo inteligente con IA' },
    { value: 'certification', label: 'üèÜ Proceso de certificaci√≥n L3' },
    { value: 'back', label: '‚¨ÖÔ∏è  Volver al men√∫ principal' }
  ];
  
  const selected = await select('üìñ Selecciona documentaci√≥n', docOptions);
  
  if (selected.value === 'back') {
    await mainMenu();
    return;
  }
  
  // Mostrar documentaci√≥n correspondiente
  showDocumentationContent(selected.value);
  
  await question('\nPresiona Enter para continuar...');
  await showDocumentation();
};

// Configuraci√≥n
const showConfiguration = async () => {
  log.title('‚öôÔ∏è  CONFIGURACI√ìN');
  
  const configPath = path.join(process.env.HOME || process.env.USERPROFILE, '.brik-config.json');
  let config = {};
  
  if (fs.existsSync(configPath)) {
    config = JSON.parse(fs.readFileSync(configPath, 'utf8'));
  }
  
  console.log('\nConfiguraci√≥n actual:');
  console.log(color(JSON.stringify(config, null, 2), colors.dim));
  
  const configOptions = [
    { value: 'api-keys', label: 'üîë Configurar API Keys (para modo inteligente)' },
    { value: 'defaults', label: 'üìù Valores por defecto' },
    { value: 'reset', label: 'üîÑ Restablecer configuraci√≥n' },
    { value: 'back', label: '‚¨ÖÔ∏è  Volver al men√∫ principal' }
  ];
  
  const selected = await select('‚öôÔ∏è  Opciones de configuraci√≥n', configOptions);
  
  if (selected.value === 'back') {
    await mainMenu();
    return;
  }
  
  if (selected.value === 'api-keys') {
    const apiKey = await question('üîë Ingresa tu API Key (Anthropic o OpenAI): ');
    const provider = await select('Proveedor', [
      { value: 'anthropic', label: 'Anthropic Claude' },
      { value: 'openai', label: 'OpenAI GPT' }
    ]);
    
    config.apiKeys = config.apiKeys || {};
    config.apiKeys[provider.value] = apiKey;
    
    fs.writeFileSync(configPath, JSON.stringify(config, null, 2));
    log.success('API Key configurada exitosamente');
  }
  
  await question('\nPresiona Enter para continuar...');
  await showConfiguration();
};

// Funciones auxiliares

const checkSmartPrerequisites = () => {
  log.info('Verificando prerrequisitos para modo inteligente...');
  
  // Verificar Node.js
  try {
    const nodeVersion = execSync('node --version', { encoding: 'utf8' }).trim();
    const majorVersion = parseInt(nodeVersion.slice(1).split('.')[0]);
    
    if (majorVersion < 18) {
      log.error(`Node.js 18+ requerido (encontrado: ${nodeVersion})`);
      return false;
    }
    log.success(`Node.js ${nodeVersion} ‚úì`);
  } catch {
    log.error('Node.js no encontrado');
    return false;
  }
  
  // Verificar API keys
  const hasApiKey = process.env.ANTHROPIC_API_KEY || process.env.OPENAI_API_KEY;
  if (!hasApiKey) {
    log.warning('No se encontraron API keys. Se usar√° Mock LLM para testing.');
    log.info('Para usar IA real, configura ANTHROPIC_API_KEY o OPENAI_API_KEY');
  } else {
    log.success('API Keys configuradas ‚úì');
  }
  
  return true;
};

const detectProjectType = (projectPath) => {
  if (fs.existsSync(path.join(projectPath, 'Cargo.toml'))) return 'rust';
  if (fs.existsSync(path.join(projectPath, 'package.json'))) return 'typescript';
  if (fs.existsSync(path.join(projectPath, 'requirements.txt'))) return 'python';
  if (fs.existsSync(path.join(projectPath, 'pyproject.toml'))) return 'python';
  if (fs.existsSync(path.join(projectPath, 'go.mod'))) return 'go';
  return null;
};

const analyzeProjectStructure = async (projectPath) => {
  log.subtitle('\nüìä An√°lisis de Estructura del Proyecto');
  
  const hasBrikStructure = fs.existsSync(path.join(projectPath, '.brik-dna.yml'));
  const hasCore = fs.existsSync(path.join(projectPath, 'src', 'core')) || 
                  fs.existsSync(path.join(projectPath, 'core'));
  const hasComponents = fs.existsSync(path.join(projectPath, 'src', 'components')) || 
                       fs.existsSync(path.join(projectPath, 'components'));
  const hasLivingLayer = fs.existsSync(path.join(projectPath, 'src', 'living-layer')) || 
                        fs.existsSync(path.join(projectPath, 'living-layer'));
  
  console.log('\n' + color('Estado BRIK:', colors.bright));
  console.log(`  ${hasBrikStructure ? '‚úÖ' : '‚ùå'} ADN BRIK (.brik-dna.yml)`);
  console.log(`  ${hasCore ? '‚úÖ' : '‚ùå'} Capa Core`);
  console.log(`  ${hasComponents ? '‚úÖ' : '‚ùå'} Capa Components/Wrappers`);
  console.log(`  ${hasLivingLayer ? '‚úÖ' : '‚ùå'} Living Layer`);
  
  // An√°lisis de cobertura si existe
  try {
    const scriptPath = path.join(projectPath, 'scripts', 'test-coverage.sh');
    if (fs.existsSync(scriptPath)) {
      log.info('\nEjecutando an√°lisis de cobertura...');
      const coverage = execSync(`cd "${projectPath}" && bash scripts/test-coverage.sh`, {
        encoding: 'utf8',
        stdio: 'pipe'
      });
      console.log(color('Cobertura: ', colors.bright) + coverage.includes('100%') ? '‚úÖ 100%' : '‚ö†Ô∏è  < 100%');
    }
  } catch {}
  
  // An√°lisis de documentaci√≥n
  const docsPath = path.join(projectPath, 'docs');
  if (fs.existsSync(docsPath)) {
    const docFiles = fs.readdirSync(docsPath);
    console.log(color('\nDocumentaci√≥n encontrada:', colors.bright));
    docFiles.slice(0, 5).forEach(file => {
      console.log(`  üìÑ ${file}`);
    });
    if (docFiles.length > 5) {
      console.log(`  ... y ${docFiles.length - 5} m√°s`);
    }
  }
};

const validateBrikStructure = async (projectPath) => {
  const validatorPath = path.join(__dirname, 'structure_validation_simple.js');
  
  if (fs.existsSync(validatorPath)) {
    try {
      const result = execSync(`node "${validatorPath}" "${projectPath}"`, {
        encoding: 'utf8',
        stdio: 'pipe'
      });
      console.log(result);
    } catch (error) {
      log.error('Validaci√≥n fall√≥: ' + error.message);
    }
  } else {
    log.warning('Validador no encontrado, mostrando an√°lisis b√°sico...');
    await analyzeProjectStructure(projectPath);
  }
};

const applyBrikRestructure = async (projectPath, mode, projectType) => {
  log.info(`Aplicando reestructuraci√≥n en modo: ${mode}`);
  
  // Crear estructura BRIK b√°sica
  const dirs = [
    'src/core',
    'src/components', 
    'src/living-layer',
    'tests/unit',
    'tests/integration',
    'tests/property',
    'tests/immutability',
    'docs/product',
    'docs/technical',
    'docs/operational',
    'scripts'
  ];
  
  dirs.forEach(dir => {
    const fullPath = path.join(projectPath, dir);
    if (!fs.existsSync(fullPath)) {
      fs.mkdirSync(fullPath, { recursive: true });
      log.success(`Creado: ${dir}`);
    }
  });
  
  // Generar archivos BRIK esenciales
  const brikDna = {
    project: {
      name: path.basename(projectPath),
      version: "1.0.0",
      philosophy: "DAAF-BRIK-CircuitalidadDigital",
      restructured: true,
      restructured_at: new Date().toISOString(),
      original_type: projectType
    },
    principles: {
      circuitality: true,
      consciousness: true,
      thermodynamics: true,
      auditability: true,
      documentation: true
    }
  };
  
  fs.writeFileSync(
    path.join(projectPath, '.brik-dna.yml'),
    `# BRIK DNA - Generado por reestructuraci√≥n\n${JSON.stringify(brikDna, null, 2)}`
  );
  
  // Copiar CIRCUITALIDAD.md
  const circuitPath = path.join(__dirname, 'CIRCUITALIDAD.md');
  if (fs.existsSync(circuitPath)) {
    fs.copyFileSync(circuitPath, path.join(projectPath, 'CIRCUITALIDAD.md'));
  }
  
  // Generar scripts de validaci√≥n
  const scripts = ['test-coverage.sh', 'brik-certify.sh', 'validate-docs.sh'];
  scripts.forEach(script => {
    const sourcePath = path.join(__dirname, 'scripts', script);
    const destPath = path.join(projectPath, 'scripts', script);
    if (fs.existsSync(sourcePath) && !fs.existsSync(destPath)) {
      fs.copyFileSync(sourcePath, destPath);
      fs.chmodSync(destPath, '755');
      log.success(`Script copiado: ${script}`);
    }
  });
  
  if (mode === 'refactor') {
    log.info('Analizando c√≥digo para refactorizaci√≥n...');
    // Aqu√≠ ir√≠a la l√≥gica de refactorizaci√≥n autom√°tica
    // Por ahora solo mostramos sugerencias
    showRefactoringSuggestions(projectPath, projectType);
  }
  
  log.success('Estructura BRIK aplicada exitosamente');
};

const showRefactoringSuggestions = (projectPath, projectType) => {
  console.log(color('\nüìù Sugerencias de Refactorizaci√≥n:', colors.bright + colors.yellow));
  console.log('');
  console.log('1. Mover l√≥gica de negocio pura a src/core/');
  console.log('2. Mover integraciones externas a src/components/');
  console.log('3. Implementar monitoreo en src/living-layer/');
  console.log('4. Agregar tests para alcanzar 100% cobertura');
  console.log('5. Completar documentaci√≥n en docs/');
  console.log('');
  log.info('Ejecuta los scripts de validaci√≥n para verificar cumplimiento BRIK');
};

const showProjectSummary = (projectPath, projectName, language) => {
  console.log(color('\nüìä Resumen del Proyecto:', colors.bright + colors.green));
  console.log(`  üìÅ Ubicaci√≥n: ${path.resolve(projectPath)}`);
  console.log(`  üè∑Ô∏è  Nombre: ${projectName}`);
  console.log(`  üíª Lenguaje: ${language}`);
  console.log(`  üß¨ Filosof√≠a: DAAF-BRIK-CircuitalidadDigital`);
  console.log('');
  console.log(color('üìã Pr√≥ximos pasos:', colors.bright));
  console.log(`  1. cd ${projectPath}`);
  console.log('  2. Revisar docs/DOCUMENTATION_CHECKLIST.md');
  console.log('  3. Instalar dependencias del proyecto');
  console.log('  4. ./scripts/test-coverage.sh (verificar 100%)');
  console.log('  5. ./scripts/brik-certify.sh (generar certificaci√≥n)');
};

const showSmartProjectAnalysis = (projectPath) => {
  console.log(color('\nüß† An√°lisis Inteligente Generado:', colors.bright + colors.magenta));
  
  const files = [
    'domain-analysis.json',
    'architecture-classification.json',
    'brik-validation-report.json'
  ];
  
  files.forEach(file => {
    const filePath = path.join(projectPath, file);
    if (fs.existsSync(filePath)) {
      console.log(`  ‚úÖ ${file}`);
    }
  });
  
  console.log('');
  console.log(color('‚ö° Caracter√≠sticas del proyecto generado:', colors.bright));
  console.log('  ‚Ä¢ C√≥digo funcional completo');
  console.log('  ‚Ä¢ Tests con 100% cobertura');
  console.log('  ‚Ä¢ Arquitectura BRIK validada');
  console.log('  ‚Ä¢ Documentaci√≥n auto-generada');
};

const showValidationReport = (report) => {
  console.log(color('\nüìä Reporte de Certificaci√≥n L3:', colors.bright + colors.cyan));
  console.log(`  Nivel: ${report.certificationLevel || 'N/A'}`);
  console.log(`  Estado: ${report.passed ? '‚úÖ APROBADO' : '‚ùå FALLIDO'}`);
  
  if (report.metrics) {
    console.log(color('\nüìà M√©tricas:', colors.bright));
    Object.entries(report.metrics).forEach(([key, value]) => {
      const icon = value >= 100 ? '‚úÖ' : value >= 80 ? '‚ö†Ô∏è' : '‚ùå';
      console.log(`  ${icon} ${key}: ${value}%`);
    });
  }
  
  if (report.recommendations && report.recommendations.length > 0) {
    console.log(color('\nüí° Recomendaciones:', colors.bright));
    report.recommendations.slice(0, 5).forEach(rec => {
      console.log(`  ‚Ä¢ ${rec}`);
    });
  }
};

const showDocumentationContent = (docType) => {
  const docs = {
    principles: `
üß¨ PRINCIPIOS BRIK Y FILOSOF√çA DAAF
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

Los proyectos BRIK siguen la filosof√≠a DAAF (Data-Augmented Agile Framework) con:

1. CIRCUITALIDAD DIGITAL
   - El c√≥digo es un circuito simb√≥lico
   - Cada l√≠nea debe estar conectada y verificada
   - 100% cobertura = circuito completo

2. ARQUITECTURA DE 3 CAPAS
   ‚Ä¢ CORE: L√≥gica pura inmutable
   ‚Ä¢ WRAPPERS: Adaptadores evolutivos
   ‚Ä¢ LIVING LAYER: Consciencia y monitoreo

3. INMUTABILIDAD POST-DEPLOYMENT
   - El core no cambia despu√©s del deploy
   - Las extensiones se hacen v√≠a wrappers
   - La evoluci√≥n es controlada

4. DOCUMENTACI√ìN INTEGRAL
   - Producto, t√©cnica, operativa
   - Auto-consistente y verificable
   - Parte del ADN del proyecto
`,
    structure: `
üìÅ ESTRUCTURA DE DIRECTORIOS BRIK
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

proyecto-brik/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ core/           # L√≥gica de negocio pura
‚îÇ   ‚îú‚îÄ‚îÄ components/     # Wrappers e integraciones
‚îÇ   ‚îî‚îÄ‚îÄ living-layer/   # Monitoreo y consciencia
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îú‚îÄ‚îÄ unit/          # Tests unitarios
‚îÇ   ‚îú‚îÄ‚îÄ integration/   # Tests de integraci√≥n
‚îÇ   ‚îú‚îÄ‚îÄ property/      # Property-based testing
‚îÇ   ‚îî‚îÄ‚îÄ immutability/  # Tests de inmutabilidad
‚îú‚îÄ‚îÄ docs/
‚îÇ   ‚îú‚îÄ‚îÄ product/       # PRD, historias de usuario
‚îÇ   ‚îú‚îÄ‚îÄ technical/     # Arquitectura, APIs
‚îÇ   ‚îî‚îÄ‚îÄ operational/   # Deploy, configuraci√≥n
‚îú‚îÄ‚îÄ scripts/           # Automatizaci√≥n
‚îú‚îÄ‚îÄ .brik-dna.yml     # ADN del proyecto
‚îî‚îÄ‚îÄ CIRCUITALIDAD.md  # Manifiesto filos√≥fico
`,
    coverage: `
üß™ GU√çA DE 100% COBERTURA
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

BRIK requiere 100% de cobertura GLOBAL y POR ARCHIVO:

1. CONFIGURACI√ìN POR LENGUAJE:
   ‚Ä¢ Rust: cargo-tarpaulin con --branch
   ‚Ä¢ TypeScript: Jest con coverageThreshold 100
   ‚Ä¢ Python: pytest-cov con --cov-fail-under=100

2. VALIDACI√ìN AUTOM√ÅTICA:
   ./scripts/test-coverage.sh
   - Verifica l√≠neas, ramas, funciones
   - Falla si alg√∫n archivo < 100%

3. ESTRATEGIAS:
   ‚Ä¢ Escribir tests primero (TDD)
   ‚Ä¢ Property-based testing
   ‚Ä¢ Tests de mutaci√≥n
   ‚Ä¢ Coverage reports en CI/CD

4. CERTIFICACI√ìN:
   Sin 100% = Sin certificaci√≥n BRIK
`,
    smart: `
üß† MODO INTELIGENTE CON IA
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

El modo inteligente usa LLMs para generar proyectos completos:

1. AN√ÅLISIS DE DOMINIO
   - Interpreta la descripci√≥n del proyecto
   - Identifica entidades y relaciones
   - Mapea integraciones necesarias

2. CLASIFICACI√ìN ARQUITECT√ìNICA
   - Separa l√≥gica CORE de WRAPPERS
   - Identifica living layer components
   - Estructura seg√∫n principios BRIK

3. GENERACI√ìN DE C√ìDIGO
   - C√≥digo funcional completo
   - Tests con 100% cobertura
   - Documentaci√≥n autom√°tica

4. VALIDACI√ìN
   - Verifica principios BRIK
   - Analiza calidad del c√≥digo
   - Genera reporte de certificaci√≥n

REQUISITOS:
‚Ä¢ Node.js 18+
‚Ä¢ API Key (Anthropic o OpenAI)
‚Ä¢ Toolchain del lenguaje objetivo
`,
    certification: `
üèÜ PROCESO DE CERTIFICACI√ìN L3
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

La certificaci√≥n L3 es el nivel empresarial m√°ximo:

NIVELES:
‚Ä¢ L1: Estructura b√°sica (60%)
‚Ä¢ L2: Cobertura y docs (80%)
‚Ä¢ L3: Enterprise-ready (95%+)

CRITERIOS L3:
‚úì Estructura BRIK completa
‚úì 100% cobertura global
‚úì Documentaci√≥n 95%+
‚úì Tests inmutabilidad
‚úì Living layer activo
‚úì CI/CD configurado
‚úì Scripts validaci√≥n
‚úì ADN proyecto (.brik-dna.yml)

VALIDACI√ìN:
node l3_certification_suite.js <proyecto>

REPORTE:
‚Ä¢ brik-l3-certification-report.json
‚Ä¢ brik-l3-certification-report.html
`
  };
  
  console.log(docs[docType] || 'Documentaci√≥n no encontrada');
};

// Funci√≥n principal
const main = async () => {
  showBanner();
  
  // Verificar si se pasaron argumentos de l√≠nea de comandos
  const args = process.argv.slice(2);
  
  if (args.length > 0) {
    // Modo CLI directo
    if (args[0] === '--help' || args[0] === '-h') {
      console.log(`
Uso: brik-cli [opciones]

Opciones:
  --help, -h        Mostrar esta ayuda
  --create <name>   Crear nuevo proyecto BRIK
  --smart <name>    Crear proyecto inteligente
  --validate <path> Validar proyecto existente
  --version, -v     Mostrar versi√≥n

Sin argumentos: Modo interactivo con men√∫
      `);
      process.exit(0);
    }
    
    if (args[0] === '--version' || args[0] === '-v') {
      console.log('BRIK CLI v5.0.0');
      process.exit(0);
    }
    
    // Procesar otros comandos...
  } else {
    // Modo interactivo
    await mainMenu();
  }
  
  rl.close();
};

// Capturar Ctrl+C
process.on('SIGINT', () => {
  console.log(color('\n\nüëã ¬°Hasta luego! Que tus proyectos sean 100% BRIK\n', colors.bright + colors.cyan));
  process.exit(0);
});

// Iniciar aplicaci√≥n
main().catch(error => {
  log.error(`Error fatal: ${error.message}`);
  process.exit(1);
});